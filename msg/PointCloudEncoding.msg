# AUTOMATICALLY GENERATED BY PROTO CONVERSION

# The point cloud has an unknown encoding.
int8 ENCODING_UNKNOWN=0
# Each point is x,y,z float32 value (12 bytes, little-endian) stored sequentially. This allows
# the point cloud to be expressed in any range and resolution represented by floating point
# numbers, but the point cloud will be larger than if one of the other encodings is used.
int8 ENCODING_XYZ_32F=1
# Each point is 3 signed int8s plus an extra shared signed int8s (4 byte).
# byte layout: [..., p1_x, p1_y, p1_z, x, ...]
# Each coordinate is mapped to a value between -1 and +1 (corresponding to a
# minimum and maximum range).
# The resulting point is:
#   P = remap(p1 * f + p2, c * f, m)
# Where:
#   p1 = the highest byte in each dimension of the point.
#   p2 = a vector of "extra" bytes converted to metric units.
#     = [mod (x, f), mod(x/f, f), mod(x/(f^2), f)] - f/2
#   x = the "extra" byte for each point.
#   f = An integer scale factor.
#   m = [max_x, max_y, max_z], the point cloud max bounds in meters.
#   c = a remapping constant.
# And:
#  remap(a, b, c) = (a + b)/(2 * b) - c
# Point clouds use 1/3 the memory of XYZ_32F, but have limits on resolution
# and range. Points must not lie outside of the box of size [-m, m]. Within that box,
# the resolution of the point cloud will depend on the encoding parameters.
# For example if m = [10, 10, 10], and f = 5 with c = 127 the resolution is
# approximately 1.5 cm per point.
int8 ENCODING_XYZ_4SC=2
# Each point is 3 signed int8s plus two extra shared signed int8s (5 byte).
# The encoding is the same as XYZ_4SC, except the "extra" value x is a 16 bit integer.
# This encoding has roughly double the resolution of XYZ_4SC, but takes up
# an additional byte for each point.
int8 ENCODING_XYZ_5SC=3

int8 value
