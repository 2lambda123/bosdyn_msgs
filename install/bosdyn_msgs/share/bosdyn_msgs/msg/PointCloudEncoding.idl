// generated from rosidl_adapter/resource/msg.idl.em
// with input from bosdyn_msgs/msg/PointCloudEncoding.msg
// generated code does not contain a copyright notice


module bosdyn_msgs {
  module msg {
    module PointCloudEncoding_Constants {
      @verbatim (language="comment", text=
        "The point cloud has an unknown encoding.")
      const int8 ENCODING_UNKNOWN = 0;
      @verbatim (language="comment", text=
        "Each point is x,y,z float32 value (12 bytes, little-endian) stored sequentially. This allows" "\n"        "the point cloud to be expressed in any range and resolution represented by floating point" "\n"        "numbers, but the point cloud will be larger than if one of the other encodings is used.")
      const int8 ENCODING_XYZ_32F = 1;
      @verbatim (language="comment", text=
        "Each point is 3 signed int8s plus an extra shared signed int8s (4 byte)." "\n"        "byte layout: [..., p1_x, p1_y, p1_z, x, ...]" "\n"        "Each coordinate is mapped to a value between -1 and +1 (corresponding to a" "\n"        "minimum and maximum range)." "\n"        "The resulting point is:" "\n"        "  P = remap(p1 * f + p2, c * f, m)" "\n"        "Where:" "\n"        "  p1 = the highest byte in each dimension of the point." "\n"        "  p2 = a vector of \"extra\" bytes converted to metric units." "\n"        "    = [mod (x, f), mod(x/f, f), mod(x/(f^2), f)] - f/2" "\n"        "  x = the \"extra\" byte for each point." "\n"        "  f = An integer scale factor." "\n"        "  m = [max_x, max_y, max_z], the point cloud max bounds in meters." "\n"        "  c = a remapping constant." "\n"        "And:" "\n"        " remap(a, b, c) = (a + b)/(2 * b) - c" "\n"        "Point clouds use 1/3 the memory of XYZ_32F, but have limits on resolution" "\n"        "and range. Points must not lie outside of the box of size [-m, m]. Within that box," "\n"        "the resolution of the point cloud will depend on the encoding parameters." "\n"        "For example if m = [10, 10, 10], and f = 5 with c = 127 the resolution is" "\n"        "approximately 1.5 cm per point.")
      const int8 ENCODING_XYZ_4SC = 2;
      @verbatim (language="comment", text=
        "Each point is 3 signed int8s plus two extra shared signed int8s (5 byte)." "\n"        "The encoding is the same as XYZ_4SC, except the \"extra\" value x is a 16 bit integer." "\n"        "This encoding has roughly double the resolution of XYZ_4SC, but takes up" "\n"        "an additional byte for each point.")
      const int8 ENCODING_XYZ_5SC = 3;
    };
    @verbatim (language="comment", text=
      "AUTOMATICALLY GENERATED BY PROTO CONVERSION")
    struct PointCloudEncoding {
      int8 value;
    };
  };
};
