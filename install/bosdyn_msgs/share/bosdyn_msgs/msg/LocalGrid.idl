// generated from rosidl_adapter/resource/msg.idl.em
// with input from bosdyn_msgs/msg/LocalGrid.msg
// generated code does not contain a copyright notice

#include "bosdyn_msgs/msg/FrameTreeSnapshot.idl"
#include "bosdyn_msgs/msg/LocalGridCellFormat.idl"
#include "bosdyn_msgs/msg/LocalGridEncoding.idl"
#include "bosdyn_msgs/msg/LocalGridExtent.idl"
#include "builtin_interfaces/msg/Time.idl"

module bosdyn_msgs {
  module msg {
    @verbatim (language="comment", text=
      "AUTOMATICALLY GENERATED BY PROTO CONVERSION")
    struct LocalGrid {
      @verbatim (language="comment", text=
        "A grid-based local grid structure, which can represent different kinds of data, such as terrain" "\n"
        "or obstacle data." "\n"
        "The human readable string name that is used to identify the type of local grid data.")
      string local_grid_type_name;

      @verbatim (language="comment", text=
        "The time at which the local grid data was computed and last valid at.")
      builtin_interfaces::msg::Time acquisition_time;

      boolean acquisition_time_is_set;

      @verbatim (language="comment", text=
        "A tree-based collection of transformations, which will include the transformations to each of" "\n"
        "the returned local grids in addition to transformations to the common frames (\"vision\", \"body\", \"odom\")." "\n"
        "All transforms within the snapshot are at the acquistion time of the local grid.")
      bosdyn_msgs::msg::FrameTreeSnapshot transforms_snapshot;

      boolean transforms_snapshot_is_set;

      @verbatim (language="comment", text=
        "The frame name for the local grid data. This frame refers to the corner of cell (0, 0), such that" "\n"
        "the map data is in the +x, +y quadrant." "\n"
        "The cell data is packed in x-y order, so the cell at:" "\n"
        "  data" "\n"
        "has its center at position:" "\n"
        "  {(xi + 0.5) * extent.cell_size, (yj + 0.5) * extent.cell_size}.")
      @unit (value="xi + extent.num_cells_x * yj")
      string frame_name_local_grid_data;

      @verbatim (language="comment", text=
        "Location, size and resolution of the local grid.")
      bosdyn_msgs::msg::LocalGridExtent extent;

      boolean extent_is_set;

      @verbatim (language="comment", text=
        "Describes the data type of a cell." "\n"
        "The data type of all individual cells in the local grid.")
      bosdyn_msgs::msg::LocalGridCellFormat cell_format;

      @verbatim (language="comment", text=
        "Encoding used for storing the local grid." "\n"
        "The encoding for the 'data' field of the local grid message.")
      bosdyn_msgs::msg::LocalGridEncoding encoding;

      @verbatim (language="comment", text=
        "The encoded local grid representation." "\n"
        "Cells are encoded according to the encoding enum, and are stored in in row-major order (x-major)." "\n"
        "This means that the data field has data entered row by row. The grid cell located at (i, j) will be" "\n"
        "at the (index = i * num_cells_x + j) within the data array.")
      sequence<octet> data;

      @verbatim (language="comment", text=
        "RLE pixel repetition counts: use data[i] repeated rle_counts[i] times when decoding the" "\n"
        "bytes data field.")
      sequence<int32> rle_counts;

      @verbatim (language="comment", text=
        "The scale for the cell value data; only valid if it is a non-zero number.")
      double cell_value_scale;

      @verbatim (language="comment", text=
        "A fixed value offset that is applied to each value of the cell data." "\n"
        "Actual values in local grid are: (({value from data} * cell_value_scale) + cell_value_offset).")
      double cell_value_offset;
    };
  };
};
