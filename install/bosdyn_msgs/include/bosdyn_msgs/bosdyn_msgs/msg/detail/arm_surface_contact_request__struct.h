// generated from rosidl_generator_c/resource/idl__struct.h.em
// with input from bosdyn_msgs:msg/ArmSurfaceContactRequest.idl
// generated code does not contain a copyright notice

#ifndef BOSDYN_MSGS__MSG__DETAIL__ARM_SURFACE_CONTACT_REQUEST__STRUCT_H_
#define BOSDYN_MSGS__MSG__DETAIL__ARM_SURFACE_CONTACT_REQUEST__STRUCT_H_

#ifdef __cplusplus
extern "C"
{
#endif

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>


// Constants defined in the message

// Include directives for member types
// Member 'root_frame_name'
#include "rosidl_runtime_c/string.h"
// Member 'wrist_tform_tool'
// Member 'root_tform_task'
#include "geometry_msgs/msg/detail/pose__struct.h"
// Member 'pose_trajectory_in_task'
#include "bosdyn_msgs/msg/detail/se3_trajectory__struct.h"
// Member 'joint_configuration'
#include "bosdyn_msgs/msg/detail/arm_surface_contact_request_one_of_joint_configuration__struct.h"
// Member 'x_axis'
// Member 'y_axis'
// Member 'z_axis'
#include "bosdyn_msgs/msg/detail/arm_surface_contact_request_axis_mode__struct.h"
// Member 'press_force_percentage'
// Member 'bias_force_ewrt_body'
#include "geometry_msgs/msg/detail/vector3__struct.h"
// Member 'xy_admittance'
// Member 'z_admittance'
// Member 'xy_to_z_cross_term_admittance'
#include "bosdyn_msgs/msg/detail/arm_surface_contact_request_admittance_setting__struct.h"
// Member 'gripper_command'
#include "bosdyn_msgs/msg/detail/claw_gripper_command_request__struct.h"

/// Struct defined in msg/ArmSurfaceContactRequest in the package bosdyn_msgs.
/**
  * AUTOMATICALLY GENERATED BY PROTO CONVERSION
 */
typedef struct bosdyn_msgs__msg__ArmSurfaceContactRequest
{
  /// The root frame is used to set the optional task frame that all trajectories are
  /// specified with respect to.  If the optional task frame is left un-specified it defaults
  /// to the identity transform and the root frame becomes the task frame.
  rosidl_runtime_c__String root_frame_name;
  /// The tool pose relative to the parent link (wrist).
  /// Defaults to
  ///    [0.19557 0 0]
  ///    [1 0 0 0]
  /// a frame with it's origin slightly in front of the gripper's palm plate aligned with wrists orientation.
  geometry_msgs__msg__Pose wrist_tform_tool;
  bool wrist_tform_tool_is_set;
  /// The fields below are specified in this optional task frame.  If unset int defaults
  /// to the identity transform and all quantities are therefore expressed in the root_frame_name.
  geometry_msgs__msg__Pose root_tform_task;
  bool root_tform_task_is_set;
  /// A 3D pose trajectory for the tool expressed in the task frame, e.g. task_T_tool.
  /// This pose trajectory is optional if requesting a pure wrench at the end-effector,
  /// otherwise required for position or mixed force/position end-effector requests.
  bosdyn_msgs__msg__SE3Trajectory pose_trajectory_in_task;
  bool pose_trajectory_in_task_is_set;
  /// Optional Maximum acceleration magnitude of the end-effector.
  /// Valid ranges (0, 20]
  double maximum_acceleration;
  bool maximum_acceleration_is_set;
  /// Optional Maximum linear velocity magnitude of the end-effector. (m/s)
  double max_linear_velocity;
  bool max_linear_velocity_is_set;
  /// Optional Maximum angular velocity magnitude of the end-effector. (rad/s)
  double max_angular_velocity;
  bool max_angular_velocity_is_set;
  /// Maximum allowable tracking error of the tool frame from the desired trajectory
  /// before the arm will stop moving and cancel the rest of the trajectory. When this limit is exceeded, the
  /// hand will stay at the pose it was at when it exceeded the tracking error, and any other part of the
  /// trajectory specified in the rest of this message will be ignored.
  /// max position tracking error in meters
  double max_pos_tracking_error;
  bool max_pos_tracking_error_is_set;
  /// max orientation tracking error in radians
  double max_rot_tracking_error;
  bool max_rot_tracking_error_is_set;
  /// Set a "preferred joint configuration" for this trajectory. When near a singularity, the robot will move towards
  /// the specified pose. If no pose is provided (ie no value is set for this oneof), a default one will be
  /// chosen. If the user wishes to explicitly tell the robot to not prefer any pose, (useful if doing a
  /// local move, and the user wants to avoid large joint motions) they should set ignore_joint_configuration
  /// to be true. The robot's behavior around singularities will then be to simply minimize joint velocity,
  /// resulting in the robot coming in and out of the singularity with similar joint angles
  bosdyn_msgs__msg__ArmSurfaceContactRequestOneOfJointConfiguration joint_configuration;
  /// If an axis is set to position mode (default), read desired from SE3Trajectory command.
  /// If mode is set to force, use the "press_force_percentage" field to determine force.
  bosdyn_msgs__msg__ArmSurfaceContactRequestAxisMode x_axis;
  bosdyn_msgs__msg__ArmSurfaceContactRequestAxisMode y_axis;
  bosdyn_msgs__msg__ArmSurfaceContactRequestAxisMode z_axis;
  /// Amount of force to use on each axis, from 0 (no force) to 1.0 (maximum force), can also
  /// be negative.  Full range: [-1.0, 1.0]
  geometry_msgs__msg__Vector3 press_force_percentage;
  bool press_force_percentage_is_set;
  /// Parameters for controlling admittance.  By default, the robot will
  /// stop moving the arm when it encounters resistance.  You can control that reaction to
  /// make the robot stiffer or less stiff by changing the parameters.
  /// Admittance settings for each axis in the admittance frame.
  bosdyn_msgs__msg__ArmSurfaceContactRequestAdmittanceSetting xy_admittance;
  bosdyn_msgs__msg__ArmSurfaceContactRequestAdmittanceSetting z_admittance;
  /// Cross term, making force in the XY axis cause movement in the z-axis.
  /// By default is OFF
  /// Setting this value will make the arm move in the negative Z-axis whenever it feels force in
  /// the XY axis.
  bosdyn_msgs__msg__ArmSurfaceContactRequestAdmittanceSetting xy_to_z_cross_term_admittance;
  /// Specifies a force that the body should expect to feel.  This allows the robot to "lean into"
  /// an external force.  Be careful using this field, because if you lie to the robot, it can
  /// fall over.
  geometry_msgs__msg__Vector3 bias_force_ewrt_body;
  bool bias_force_ewrt_body_is_set;
  /// Gripper control
  bosdyn_msgs__msg__ClawGripperCommandRequest gripper_command;
  bool gripper_command_is_set;
  /// Set to true to have robot is walk around to follow the hand.
  bool is_robot_following_hand;
} bosdyn_msgs__msg__ArmSurfaceContactRequest;

// Struct for a sequence of bosdyn_msgs__msg__ArmSurfaceContactRequest.
typedef struct bosdyn_msgs__msg__ArmSurfaceContactRequest__Sequence
{
  bosdyn_msgs__msg__ArmSurfaceContactRequest * data;
  /// The number of valid items in data
  size_t size;
  /// The number of allocated items in data
  size_t capacity;
} bosdyn_msgs__msg__ArmSurfaceContactRequest__Sequence;

#ifdef __cplusplus
}
#endif

#endif  // BOSDYN_MSGS__MSG__DETAIL__ARM_SURFACE_CONTACT_REQUEST__STRUCT_H_
