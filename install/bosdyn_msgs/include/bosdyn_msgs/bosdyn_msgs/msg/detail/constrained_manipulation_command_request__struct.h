// generated from rosidl_generator_c/resource/idl__struct.h.em
// with input from bosdyn_msgs:msg/ConstrainedManipulationCommandRequest.idl
// generated code does not contain a copyright notice

#ifndef BOSDYN_MSGS__MSG__DETAIL__CONSTRAINED_MANIPULATION_COMMAND_REQUEST__STRUCT_H_
#define BOSDYN_MSGS__MSG__DETAIL__CONSTRAINED_MANIPULATION_COMMAND_REQUEST__STRUCT_H_

#ifdef __cplusplus
extern "C"
{
#endif

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>


// Constants defined in the message

// Include directives for member types
// Member 'frame_name'
#include "rosidl_runtime_c/string.h"
// Member 'init_wrench_direction_in_frame_name'
#include "geometry_msgs/msg/detail/wrench__struct.h"
// Member 'task_speed'
#include "bosdyn_msgs/msg/detail/constrained_manipulation_command_request_one_of_task_speed__struct.h"
// Member 'task_type'
#include "bosdyn_msgs/msg/detail/constrained_manipulation_command_request_task_type__struct.h"
// Member 'end_time'
#include "builtin_interfaces/msg/detail/time__struct.h"
// Member 'control_mode'
#include "bosdyn_msgs/msg/detail/constrained_manipulation_command_request_control_mode__struct.h"
// Member 'task_target_position'
#include "bosdyn_msgs/msg/detail/constrained_manipulation_command_request_one_of_task_target_position__struct.h"

/// Struct defined in msg/ConstrainedManipulationCommandRequest in the package bosdyn_msgs.
/**
  * AUTOMATICALLY GENERATED BY PROTO CONVERSION
 */
typedef struct bosdyn_msgs__msg__ConstrainedManipulationCommandRequest
{
  /// Frame that the initial wrench will be expressed in
  rosidl_runtime_c__String frame_name;
  /// Direction of the initial wrench to be applied
  /// Depending on the task, either the force vector or the
  /// torque vector are required to be specified. The required
  /// vector should not have a magnitude of zero and will be
  /// normalized to 1. For tasks that require the force vector,
  /// the torque vector can still be specified as a non-zero vector
  /// if it is a good guess of the axis of rotation of the task.
  /// (for e.g. TASK_TYPE_SE3_ROTATIONAL_TORQUE task types.)
  /// Note that if both vectors are non-zero, they have to be perpendicular.
  /// Once the constrained manipulation system estimates the
  /// constraint, the init_wrench_direction and frame_name
  /// will no longer be used.
  geometry_msgs__msg__Wrench init_wrench_direction_in_frame_name;
  bool init_wrench_direction_in_frame_name_is_set;
  /// The desired velocity to move the object
  /// For all tasks besides SE3_ROTATIONAL_TORQUE, set
  /// tangential_speed in units of m/s. For SE3_ROTATIONAL_TORQUE,
  /// set rotational_speed with units of rad/s.
  bosdyn_msgs__msg__ConstrainedManipulationCommandRequestOneOfTaskSpeed task_speed;
  /// The limit on the force that is applied on any translation direction
  /// Value must be positive
  /// If unspecified, a default value of 40 N will be used.
  double force_limit;
  bool force_limit_is_set;
  /// The limit on the torque that is applied on any rotational direction
  /// Value must be positive
  /// If unspecified, a default value of 4 Nm will be used.
  double torque_limit;
  bool torque_limit_is_set;
  /// Geometrical category of a task. See the constrained_manipulation_helper function
  /// for examples of each of these categories. For e.g. SE3_CIRCLE_FORCE_TORQUE corresponds
  /// to lever type objects.
  bosdyn_msgs__msg__ConstrainedManipulationCommandRequestTaskType task_type;
  /// The timestamp (in robot time) by which a command must finish executing.
  /// This is a required field and used to prevent runaway commands.
  builtin_interfaces__msg__Time end_time;
  bool end_time_is_set;
  /// Whether to enable the robot to take steps during constrained manip to keep the hand in
  /// the workspace.
  bool enable_robot_locomotion;
  bool enable_robot_locomotion_is_set;
  bosdyn_msgs__msg__ConstrainedManipulationCommandRequestControlMode control_mode;
  /// Desired final task position to achieve
  /// The position is computed relative to the starting position.
  bosdyn_msgs__msg__ConstrainedManipulationCommandRequestOneOfTaskTargetPosition task_target_position;
  /// Acceleration limit for the planned trajectory in the free task DOF.
  /// Note that the units of this variable will be m/(s^2) or rad/(s^2) depending
  /// on the choice of target_linear_position vs. target_angle above.
  double accel_limit;
  bool accel_limit_is_set;
  /// Constrained manipulation estimates the task frame given the observed initial motion.
  /// Setting this to false saves and uses the estimation state from the previous
  /// constrained manipulation move. This is true by default.
  bool reset_estimator;
  bool reset_estimator_is_set;
} bosdyn_msgs__msg__ConstrainedManipulationCommandRequest;

// Struct for a sequence of bosdyn_msgs__msg__ConstrainedManipulationCommandRequest.
typedef struct bosdyn_msgs__msg__ConstrainedManipulationCommandRequest__Sequence
{
  bosdyn_msgs__msg__ConstrainedManipulationCommandRequest * data;
  /// The number of valid items in data
  size_t size;
  /// The number of allocated items in data
  size_t capacity;
} bosdyn_msgs__msg__ConstrainedManipulationCommandRequest__Sequence;

#ifdef __cplusplus
}
#endif

#endif  // BOSDYN_MSGS__MSG__DETAIL__CONSTRAINED_MANIPULATION_COMMAND_REQUEST__STRUCT_H_
