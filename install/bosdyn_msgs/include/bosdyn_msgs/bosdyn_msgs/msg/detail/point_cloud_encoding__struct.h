// generated from rosidl_generator_c/resource/idl__struct.h.em
// with input from bosdyn_msgs:msg/PointCloudEncoding.idl
// generated code does not contain a copyright notice

#ifndef BOSDYN_MSGS__MSG__DETAIL__POINT_CLOUD_ENCODING__STRUCT_H_
#define BOSDYN_MSGS__MSG__DETAIL__POINT_CLOUD_ENCODING__STRUCT_H_

#ifdef __cplusplus
extern "C"
{
#endif

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>


// Constants defined in the message

/// Constant 'ENCODING_UNKNOWN'.
/**
  * The point cloud has an unknown encoding.
 */
enum
{
  bosdyn_msgs__msg__PointCloudEncoding__ENCODING_UNKNOWN = 0
};

/// Constant 'ENCODING_XYZ_32F'.
/**
  * Each point is x,y,z float32 value (12 bytes, little-endian) stored sequentially. This allows
  * the point cloud to be expressed in any range and resolution represented by floating point
  * numbers, but the point cloud will be larger than if one of the other encodings is used.
 */
enum
{
  bosdyn_msgs__msg__PointCloudEncoding__ENCODING_XYZ_32F = 1
};

/// Constant 'ENCODING_XYZ_4SC'.
/**
  * Each point is 3 signed int8s plus an extra shared signed int8s (4 byte).
  * byte layout: [..., p1_x, p1_y, p1_z, x, ...]
  * Each coordinate is mapped to a value between -1 and +1 (corresponding to a
  * minimum and maximum range).
  * The resulting point is:
  *   P = remap(p1 * f + p2, c * f, m)
  * Where:
  *   p1 = the highest byte in each dimension of the point.
  *   p2 = a vector of "extra" bytes converted to metric units.
  *     = [mod (x, f), mod(x/f, f), mod(x/(f^2), f)] - f/2
  *   x = the "extra" byte for each point.
  *   f = An integer scale factor.
  *   m = [max_x, max_y, max_z], the point cloud max bounds in meters.
  *   c = a remapping constant.
  * And:
  *  remap(a, b, c) = (a + b)/(2 * b) - c
  * Point clouds use 1/3 the memory of XYZ_32F, but have limits on resolution
  * and range. Points must not lie outside of the box of size [-m, m]. Within that box,
  * the resolution of the point cloud will depend on the encoding parameters.
  * For example if m = [10, 10, 10], and f = 5 with c = 127 the resolution is
  * approximately 1.5 cm per point.
 */
enum
{
  bosdyn_msgs__msg__PointCloudEncoding__ENCODING_XYZ_4SC = 2
};

/// Constant 'ENCODING_XYZ_5SC'.
/**
  * Each point is 3 signed int8s plus two extra shared signed int8s (5 byte).
  * The encoding is the same as XYZ_4SC, except the "extra" value x is a 16 bit integer.
  * This encoding has roughly double the resolution of XYZ_4SC, but takes up
  * an additional byte for each point.
 */
enum
{
  bosdyn_msgs__msg__PointCloudEncoding__ENCODING_XYZ_5SC = 3
};

/// Struct defined in msg/PointCloudEncoding in the package bosdyn_msgs.
/**
  * AUTOMATICALLY GENERATED BY PROTO CONVERSION
 */
typedef struct bosdyn_msgs__msg__PointCloudEncoding
{
  int8_t value;
} bosdyn_msgs__msg__PointCloudEncoding;

// Struct for a sequence of bosdyn_msgs__msg__PointCloudEncoding.
typedef struct bosdyn_msgs__msg__PointCloudEncoding__Sequence
{
  bosdyn_msgs__msg__PointCloudEncoding * data;
  /// The number of valid items in data
  size_t size;
  /// The number of allocated items in data
  size_t capacity;
} bosdyn_msgs__msg__PointCloudEncoding__Sequence;

#ifdef __cplusplus
}
#endif

#endif  // BOSDYN_MSGS__MSG__DETAIL__POINT_CLOUD_ENCODING__STRUCT_H_
