// generated from rosidl_generator_c/resource/idl__struct.h.em
// with input from bosdyn_msgs:msg/FrameTreeSnapshot.idl
// generated code does not contain a copyright notice

#ifndef BOSDYN_MSGS__MSG__DETAIL__FRAME_TREE_SNAPSHOT__STRUCT_H_
#define BOSDYN_MSGS__MSG__DETAIL__FRAME_TREE_SNAPSHOT__STRUCT_H_

#ifdef __cplusplus
extern "C"
{
#endif

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>


// Constants defined in the message

// Include directives for member types
// Member 'child_to_parent_edge_map'
#include "bosdyn_msgs/msg/detail/key_string_value_bosdyn_msgs_frame_tree_snapshot_parent_edge__struct.h"

/// Struct defined in msg/FrameTreeSnapshot in the package bosdyn_msgs.
/**
  * AUTOMATICALLY GENERATED BY PROTO CONVERSION
 */
typedef struct bosdyn_msgs__msg__FrameTreeSnapshot
{
  ///      *   A frame is a named location in space.
  ///      * For example, the following frames are defined by the API:
  ///      *  - "body":   A frame centered on the robot's body.
  ///      *  - "vision": A non-moving (inertial) frame that is the robot's best
  ///      *              estimate of a fixed location in the world. It is based on
  ///      *              both dead reckoning and visual analysis of the world.
  ///      *  - "odom":   A non-moving (inertial) frame that is based on the kinematic
  ///      *              odometry of the robot only.
  ///      * Additional frames are available for robot joints, sensors, and items
  ///      * detected in the world.
  ///      *
  ///      * The FrameTreeSnapshot represents the relationships between the frames that the robot
  ///      * knows about at a particular point in time. For example, with the FrameTreeSnapshot,
  ///      * an API client can determine where the "body" is relative to the "vision".
  ///      *
  ///      * To reduce data bandwidth, the FrameTreeSnapshot will typically contain
  ///      * a small subset of all known frames. By default, all services MUST
  ///      * include "vision", "body", and "odom" frames in the FrameTreeSnapshot, but
  ///      * additional frames can also be included. For example, an Image service
  ///      * would likely include the frame located at the base of the camera lens
  ///      * where the picture was taken.
  ///      *
  ///      * Frame relationships are expressed as edges between "parent" frames and
  ///      * "child" frames, with an SE3Pose indicating the pose of the "child" frame
  ///      * expressed in the "parent" frame. These edges are included in the edge_map
  ///      * field. For example, if frame "hand" is 1m in front of the frame "shoulder",
  ///      * then the FrameTreeSnapshot might contain:
  ///      *  edge_map {
  ///      *     key: "hand"
  ///      *     value: {
  ///      *         parent_frame_name: "shoulder"
  ///      *         parent_tform_child: {
  ///      *            position: {
  ///      *              x: 1.0
  ///      *              y: 0.0
  ///      *              z: 0.0
  ///      *            }
  ///      *         }
  ///      *      }
  ///      *  }
  ///      *
  ///      * Frame relationships can be inverted. So, to find where the "shoulder"
  ///      * is in relationship the "hand", the parent_tform_child pose in the edge
  ///      * above can be inverted:
  ///      *      hand_tform_shoulder = shoulder_tform_hand.inverse()
  ///      * Frame relationships can also be concatenated. If there is an additional
  ///      * edge specifying the pose of the "shoulder" relative to the "body", then
  ///      * to find where the "hand" is relative to the "body" do:
  ///      *      body_tform_hand = body_tform_shoulder * shoulder_tform_hand
  ///      *
  ///      * The two properties above reduce data size. Instead of having to send N^2
  ///      * edge_map entries to represent all relationships between N frames,
  ///      * only N edge_map entries need to be sent. Clients will need to determine
  ///      * the chain of edges to follow to get from one frame to another frae,
  ///      * and then do inversion and concatentation to generate the appropriate pose.
  ///      *
  ///      * Note that all FrameTreeSnapshots are expected to be a single rooted tree.
  ///      * The syntax for FrameTreeSnapshot could also support graphs with
  ///      * cycles, or forests of trees - but clients should treat those as invalid
  ///      * representations.
  ///      *
  /// ParentEdge represents the relationship from a child frame to a parent frame.
  /// child_to_parent_edge_map maps the child frame name to the ParentEdge.
  /// In aggregate, this forms the tree structure.
  bosdyn_msgs__msg__KeyStringValueBosdynMsgsFrameTreeSnapshotParentEdge__Sequence child_to_parent_edge_map;
} bosdyn_msgs__msg__FrameTreeSnapshot;

// Struct for a sequence of bosdyn_msgs__msg__FrameTreeSnapshot.
typedef struct bosdyn_msgs__msg__FrameTreeSnapshot__Sequence
{
  bosdyn_msgs__msg__FrameTreeSnapshot * data;
  /// The number of valid items in data
  size_t size;
  /// The number of allocated items in data
  size_t capacity;
} bosdyn_msgs__msg__FrameTreeSnapshot__Sequence;

#ifdef __cplusplus
}
#endif

#endif  // BOSDYN_MSGS__MSG__DETAIL__FRAME_TREE_SNAPSHOT__STRUCT_H_
