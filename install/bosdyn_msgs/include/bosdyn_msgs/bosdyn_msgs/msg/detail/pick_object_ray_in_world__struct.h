// generated from rosidl_generator_c/resource/idl__struct.h.em
// with input from bosdyn_msgs:msg/PickObjectRayInWorld.idl
// generated code does not contain a copyright notice

#ifndef BOSDYN_MSGS__MSG__DETAIL__PICK_OBJECT_RAY_IN_WORLD__STRUCT_H_
#define BOSDYN_MSGS__MSG__DETAIL__PICK_OBJECT_RAY_IN_WORLD__STRUCT_H_

#ifdef __cplusplus
extern "C"
{
#endif

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>


// Constants defined in the message

// Include directives for member types
// Member 'ray_start_rt_frame'
// Member 'ray_end_rt_frame'
#include "geometry_msgs/msg/detail/vector3__struct.h"
// Member 'frame_name'
#include "rosidl_runtime_c/string.h"
// Member 'grasp_params'
#include "bosdyn_msgs/msg/detail/grasp_params__struct.h"
// Member 'walk_gaze_mode'
#include "bosdyn_msgs/msg/detail/walk_gaze_mode__struct.h"

/// Struct defined in msg/PickObjectRayInWorld in the package bosdyn_msgs.
/**
  * AUTOMATICALLY GENERATED BY PROTO CONVERSION
 */
typedef struct bosdyn_msgs__msg__PickObjectRayInWorld
{
  /// Cast a ray in the world and pick the first object found along the ray.
  /// This is the lowest-level grasping message; all other grasp options internally use this
  /// message to trigger a grasp.
  /// Example:
  ///  You see the object you are interested in with the gripper's camera.  To grasp it, you
  ///  cast a ray from the camera out to 4 meters (well past the object).
  ///  To do this you'd set:
  ///      ray_start_rt_frame: camera's position
  ///      ray_end_rt_frame: camera's position + unit vector along ray of interest * 4 meters
  geometry_msgs__msg__Vector3 ray_start_rt_frame;
  bool ray_start_rt_frame_is_set;
  geometry_msgs__msg__Vector3 ray_end_rt_frame;
  bool ray_end_rt_frame_is_set;
  /// Name of the frame the above parameters are represented in.
  rosidl_runtime_c__String frame_name;
  /// Optional parameters for the grasp.
  bosdyn_msgs__msg__GraspParams grasp_params;
  bool grasp_params_is_set;
  /// Configure if the robot should automatically walk and/or gaze at the target object before
  /// performing the grasp.
  /// 1. If you haven't moved the robot or deployed the arm, use PICK_AUTO_WALK_AND_GAZE
  /// 2. If you have moved to the location you want to pick from, but haven't yet deployed the arm,
  ///    use PICK_AUTO_GAZE.
  /// 3. If you have already moved the robot and have the hand looking at your target object, use
  ///    PICK_NO_AUTO_WALK_OR_GAZE.
  /// If you are seeing issues with "MANIP_STATE_GRASP_FAILED_TO_RAYCAST_INTO_MAP," that means that
  /// the automatic system cannot find your object when trying to automatically walk to it, so
  /// consider using PICK_AUTO_GAZE or PICK_NO_AUTO_WALK_OR_GAZE.
  bosdyn_msgs__msg__WalkGazeMode walk_gaze_mode;
} bosdyn_msgs__msg__PickObjectRayInWorld;

// Struct for a sequence of bosdyn_msgs__msg__PickObjectRayInWorld.
typedef struct bosdyn_msgs__msg__PickObjectRayInWorld__Sequence
{
  bosdyn_msgs__msg__PickObjectRayInWorld * data;
  /// The number of valid items in data
  size_t size;
  /// The number of allocated items in data
  size_t capacity;
} bosdyn_msgs__msg__PickObjectRayInWorld__Sequence;

#ifdef __cplusplus
}
#endif

#endif  // BOSDYN_MSGS__MSG__DETAIL__PICK_OBJECT_RAY_IN_WORLD__STRUCT_H_
